---
title: "ADR-001: i18n LSP技術スタック選定"
type: "Architecture Decision Record"
adr_number: "001"
created_date: "2025-06-01"
author: "Kohei Watanabe"
approver: "Kohei Watanabe"
status: "accepted"
category: "technology"
impact_level: "high"
---

# ADR-001: i18n LSP技術スタック選定

## ステータス

**現在のステータス:** 採用済み

**決定日:** 2025-06-01

**関連する決定:**

- 置き換える決定: なし（初期ADR）
- 関連する決定: ADR-002（テスト戦略）
- この決定により置き換えられる: 将来的に更新

---

## コンテキスト

### 背景・状況

多言語対応プロジェクトにおける開発効率を向上させるため、i18n（国際化）専用のLanguage Server Protocol (LSP) サーバーを開発する必要がある。  
このLSPサーバーは、翻訳キーの補完、検証、リファクタリング、バーチャルテキスト表示などの機能を提供し、開発者の多言語対応作業を支援する。

**現在の状況:**

- 多言語対応アプリケーションの開発において、手動での翻訳キー管理が必要
- 翻訳キーの補完機能がなく、開発効率が低い
- 既存のi18n専用LSPサーバーが存在しない

**解決すべき問題:**

- 翻訳キーの自動補完機能の不足
- 翻訳ファイルと実装コードの整合性チェック機能の不足
- 大規模プロジェクトでのリアルタイム応答性が必要

### 制約条件

**技術的制約:**

- LSPプロトコル標準への準拠が必要
- Rust stable (1.75+) での実装
- 1000+キーでリアルタイム補完が必要（<100ms）

**ビジネス制約:**

- 個人開発プロジェクトのため、学習コストを抑制
- 実装・保守のリソースが限定的
- 迅速なプロトタイピングが必要

**外部制約:**

- 主要エディタ（VSCode、Neovim等）との互換性
- オープンソースエコシステムとの親和性

---

## 検討した選択肢

### 選択肢A: tower-lsp + tokio + tree-sitter

**概要:**
非同期ファーストのLSPフレームワークとインクリメンタル構文解析の組み合わせ

**メリット:**

- 非同期I/O処理の効率的な実装
- Denoでの採用実績（パフォーマンス改善実証済み）
- インクリメンタル解析による高速化
- 豊富なミドルウェア機能

**デメリット:**

- tokioエコシステムへの依存
- バイナリサイズ約10-15MB
- 非同期Rustの学習曲線

**実装コスト:** 中  
**技術的複雑さ:** 中  
**リスク:** 低

### 選択肢B: lsp-server + 手動非同期実装

**概要:**
同期的なLSPフレームワークに手動で非同期処理を追加

**メリット:**

- より細かい制御が可能
- 軽量な実装
- tokio依存の削減

**デメリット:**

- 実装の複雑化とボイラープレート増加
- 保守性の低下
- エラーハンドリングの困難さ
- 非同期処理の手動実装によるバグリスク

**実装コスト:** 高  
**技術的複雑さ:** 高  
**リスク:** 高

### 選択肢C: TypeScript + @vscode/lsp-node

**概要:**
TypeScriptでの実装によるプロトタイピング

**メリット:**

- 開発速度が速い
- 既存のTypeScriptエコシステムを活用可能
- JSエコシステムの豊富なライブラリ

**デメリット:**

- パフォーマンスの限界
- 大規模プロジェクトでのスケーラビリティ問題
- メモリ使用量の増大

**実装コスト:** 低  
**技術的複雑さ:** 低  
**リスク:** 中

### 比較表

| 観点               | 選択肢A | 選択肢B | 選択肢C | 重要度 |
| ------------------ | ------- | ------- | ------- | ------ |
| **パフォーマンス** | 高      | 中      | 低      | 高     |
| **開発コスト**     | 中      | 高      | 低      | 中     |
| **保守性**         | 高      | 低      | 中      | 高     |
| **学習コスト**     | 中      | 高      | 低      | 中     |
| **将来性**         | 高      | 中      | 中      | 高     |

---

## 決定

### 採用する選択肢

**選択:** 選択肢A（tower-lsp + tokio + tree-sitter）

**決定理由:**

1. 非同期処理の必要性: i18n LSPは多数のファイルI/O操作を含むため、非同期処理が必須
2. 実績: Denoプロジェクトでの採用により、劇的なパフォーマンス改善が実証済み
3. 開発効率: 非同期処理、エラーハンドリング、ミドルウェア機能が組み込み済み
4. 作成者の主観的な好みにより、Rust を使用したいという要望も考慮

### 決定の詳細

**実装方針:**

- tower-lspをベースとしたLSPサーバー実装
- tokioによる非同期ランタイム
- tree-sitterによるインクリメンタル構文解析

**技術的詳細:**

```yaml
# 採用技術スタック
framework: "tower-lsp 0.20"
async_runtime: "tokio 1.35"
parser: "tree-sitter 0.20"
serialization: "serde + serde_json"
concurrent_collections: "dashmap 5.5"
```

**設計原則:**

- ビジネスロジックをLSP実装から分離
- 非同期処理を活用した高パフォーマンス
- テスタブルな設計

---

## 結果・影響

### ポジティブな影響

**短期的効果:**

- tower-lspの豊富な機能により開発速度向上
- 非同期処理による高いスループット
- インクリメンタル解析による低レイテンシ

**長期的効果:**

- 大規模プロジェクトでも高性能を維持
- アクティブに開発されているエコシステム
- 将来的な機能拡張の基盤

### ネガティブな影響・トレードオフ

**受け入れるコスト:**

- tokioエコシステムへの依存
- 非同期Rustの学習曲線
- バイナリサイズの増加（約10-15MB）

**リスク・課題:**

- エコシステムの変化に対する追随コスト
- 軽減策: 安定したバージョンの採用と段階的アップデート

### 影響範囲

**技術的影響:**

- 全モジュールが非同期設計となる
- エラーハンドリング戦略の統一
- テスト戦略の見直し（非同期テスト）

**組織的影響:**

- 非同期Rustのスキル習得が必要
- パフォーマンス重視の開発文化

---

## 実装計画

### フェーズ1: 基盤構築

**期間:** 2週間

**実施内容:**

- [ ] tower-lspベースのLSPサーバー骨格実装
- [ ] 基本的なリクエスト/レスポンスハンドリング
- [ ] ログとトレーシングの設定

**成功基準:**

- LSPクライアントとの基本通信確立
- 初期化・シャットダウンが正常動作

### フェーズ2: コア機能実装

**期間:** 4週間

**実施内容:**

- [ ] tree-sitterによる構文解析統合
- [ ] 翻訳ファイルのパース（JSON/YAML/TOML）
- [ ] 補完・検証機能の実装

**成功基準:**

- 基本的な補完機能の動作
- 1000キーでの性能要件達成（<100ms）

### フェーズ3: 最適化・統合

**期間:** 2週間

**実施内容:**

- [ ] パフォーマンス最適化
- [ ] エディタプラグインとの統合テスト
- [ ] ドキュメント整備

**成功基準:**

- 全機能の統合テスト完了
- パフォーマンス目標達成

---

## 監視・測定

### 成功指標

| 指標                               | 現在値 | 目標値 | 測定方法            | 責任者 |
| ---------------------------------- | ------ | ------ | ------------------- | ------ |
| 補完レスポンスタイム               | -      | <100ms | LSPクライアントログ | 開発者 |
| 1000キープロジェクトでの初期化時間 | -      | <3秒   | ベンチマーク        | 開発者 |
| メモリ使用量（1000キー）           | -      | <50MB  | プロファイラー      | 開発者 |

### 監視項目

**技術メトリクス:**

- 補完レスポンス時間
- 初期化時間
- メモリ使用量
- CPU使用率

**ビジネスメトリクス:**

- 開発効率（機能実装速度）
- バグ発生率
- ユーザー満足度

### レビュー計画

**定期レビュー:**

- 頻度: 月次
- 参加者: 開発者
- 評価項目: 成功指標の確認

**振り返りタイミング:**

- 実装完了時: フェーズごとの成果確認
- 本格運用開始後: パフォーマンス測定
- 3ヶ月後: 長期的な効果測定

---

## 学習・改善

### この決定から学んだこと

**良かった点:**

- tower-lspの機能の豊富さが予想以上に開発を加速
- 非同期設計により、将来の拡張性を確保

**改善点:**

- 初期の学習コスト見積もりが甘かった
- より詳細なベンチマーク計画が必要

### 他プロジェクトへの適用

**再利用可能な要素:**

- tower-lsp + tokioの組み合わせパターン
- 非同期設計の原則

**適用時の注意点:**

- プロジェクト規模に応じたパフォーマンス要件の調整
- チームのRustスキルレベルの考慮

---

## 参考資料

### 技術資料

- [tower-lsp Documentation](https://github.com/tower-lsp/tower-lsp)
- [Deno's migration to tower-lsp](https://github.com/denoland/deno/pull/11966)
- [tree-sitter Documentation](https://tree-sitter.github.io/tree-sitter/)

### 意思決定資料

- [Language Server Protocol Specification](https://microsoft.github.io/language-server-protocol/)
- Denoプロジェクトの性能改善レポート

### 関連ADR

- ADR-002: テスト戦略とカバレッジ目標

