# Asana活用ガイドライン - AIアシスタント向け（Rust LSPサーバー開発）

このドキュメントは、RustでのLSP（Language Server Protocol）サーバー開発プロジェクトにおいて、AIアシスタントがAsanaを効果的に活用するためのガイドラインです。

## 基本ルール

### タスクの命名規則

- **必須**: すべてのタスクにプロジェクトで一意なプレフィックスを付与する
- 例:
  - `[FEAT-001] 基本的なLSPサーバーの初期化処理`
  - `[FEAT-002] textDocument/didOpen ハンドラーの実装`
  - `[FEAT-003] i18nキー抽出ロジックの実装`
  - `[BUG-001] 補完候補の重複除去`

### タスクのステータス

- **未着手**: まだ作業を開始していない
- **作業中**: 現在作業を進めている
- **完了**: すべての作業が完了し、定義された完了条件を満たした

### 優先度の設定

- **高**: 緊急で実施すべきタスク（クリティカルなバグ、基本機能の実装）
- **中**: 通常のタスク（デフォルト）
- **低**: 時間があるときに実施すれば良いタスク（最適化、nice-to-have機能）

## ドキュメント作成担当AIの役割

### 1. タスクの作成

LSP機能単位でタスクを作成し、以下の情報を記載する：

#### タスク説明のフォーマット

```markdown
## 作業詳細

[LSPのどの機能を実装するか、どのi18n機能を追加するか具体的に記載]

### LSP仕様参照

- 関連するLSP仕様: [https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_completion]
- 実装するメソッド: `textDocument/completion`

### 技術的な詳細

- 対象モジュール:
  - `src/handlers/completion.rs`
  - `src/analyzer/i18n_keys.rs`
- 使用するクレート:
  - `tower-lsp`
  - `serde_json`
  - `regex`
- 考慮事項:
  - パフォーマンス要件
  - エラーハンドリング
  - 既存コードとの整合性

## 完了条件

以下の条件をすべて満たしたときに完了とする：

- [ ] LSPプロトコルに準拠した実装が完了
- [ ] 単体テストが追加され、すべてパスする
- [ ] 統合テストでVSCodeでの動作確認済み
- [ ] `cargo clippy`でwarningなし
- [ ] `cargo fmt`実行済み
- [ ] ドキュメントコメント追加済み

---

## 実装結果

[タスク完了時にここに結果を記録]
```

### 2. タスクの切り出し例（LSPサーバー開発）

- **基盤機能**
  - LSPサーバーの初期化
  - 基本的なリクエスト/レスポンスハンドリング
  - ログ機能の実装
- **テキストドキュメント同期**
  - didOpen/didChange/didCloseハンドラー
  - ドキュメントの状態管理
- **言語機能**
  - 補完機能（i18nキーの提案）
  - ホバー機能（翻訳内容の表示）
  - 定義へのジャンプ
  - リファレンス検索
  - 診断機能（未定義キーの検出）

## 実装担当AIの役割

### 1. 進捗の記録（コメント）

1コミットごとに以下のフォーマットでコメントを追加：

```markdown
## 進捗報告 - [日時]

### 実施内容

[具体的に何を実装したか（例：completion handlerの基本構造を実装）]

### 技術的詳細

- コミットID: `abc123def`
- PR番号: #123 （該当する場合）
- 変更ファイル:
  - `src/handlers/completion.rs` - 補完ハンドラーの実装
  - `src/analyzer/mod.rs` - i18nキー解析モジュール追加
  - `tests/completion_test.rs` - 補完機能のテスト

### 実装のポイント

- `tower-lsp`の`LanguageServer`トレイトを実装
- 非同期処理でパフォーマンスを確保
- エラーは`LspError`型で統一的に処理

### 次のステップ

[次に実施する作業（例：補完候補のフィルタリング機能追加）]
```

### 2. 決定事項の記録（コメント）

```markdown
## 決定事項 - [日時]

### 決定内容

[例：i18nキーの解析にはregexクレートを使用し、ASTパースは行わない]

### 決定理由

- パフォーマンス: regexの方が高速
- 実装の簡潔性: AST解析は複雑になりすぎる
- 十分性: 現在の要件では正規表現で十分対応可能

### 影響範囲

- `src/analyzer/`配下の実装方針
- テストの書き方

### 代替案（検討した場合）

- `swc`を使用したAST解析
  - 却下理由: オーバーエンジニアリング、依存関係が増える
```

### 3. Rust固有の記録事項

```markdown
## Rust実装メモ - [日時]

### lifetimeの設計

[複雑なlifetimeが必要な場合の設計理由]

### 並行性/非同期処理

- 使用したランタイム: tokio
- 並行処理の戦略: [具体的な内容]

### エラーハンドリング

- カスタムエラー型: `LspError`
- エラー伝播の方針: `?`演算子を活用

### パフォーマンス最適化

- 実施した最適化: [具体的な内容]
- ベンチマーク結果: [数値があれば]
```

### 4. タスク完了時の記録

```markdown
## 実装結果

### 完成した機能

[実装したLSP機能の概要（例：i18nキーの補完機能）]

### 主な変更点

- 新規作成: `completion`モジュール
- i18nキー解析ロジックの実装
- LSPプロトコル準拠のレスポンス生成

### 最終的な実装

- 総コミット数: X件
- 変更ファイル数: Y件
- 追加/削除行数: +AAA -BBB
- テストカバレッジ: XX%

### パフォーマンス

- 補完レスポンス時間: 平均XXms
- メモリ使用量: 約XXMB

### 関連リンク

- PR: #123
- 関連仕様: [LSP Specification - Completion](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_completion)

### 今後の課題（あれば）

- 大規模プロジェクトでのパフォーマンス改善
- キャッシュ機構の実装
- より高度な補完候補のランキング
```

## LSPサーバー開発特有の注意事項

### テスト戦略

1. **単体テスト**: 各ハンドラーの個別機能
2. **統合テスト**: LSPクライアントとの通信
3. **E2Eテスト**: VSCodeでの実際の動作確認

### デバッグ情報の記録

````markdown
## デバッグメモ

### LSPトレース

```json
[送受信したLSPメッセージのサンプル]
```
````

### 問題と解決策

- 問題: [具体的な問題]
- 原因: [根本原因]
- 解決策: [実施した対策]

```

## プレフィックスの詳細ルール

### LSPサーバー開発用プレフィックス
- `FEAT-XXX`: 機能開発（LSP機能、i18n機能、解析機能など）
- `BUG-XXX`: バグ修正
- `PERF-XXX`: パフォーマンス改善
- `TEST-XXX`: テスト追加/改善
- `REFACTOR-XXX`: リファクタリング
- `DOC-XXX`: ドキュメント作成/更新
- `INFRA-XXX`: ビルド/CI/CD関連

## よくある質問（LSPサーバー開発）

### Q: LSP機能の実装順序は？
A: 推奨順序：
1. 初期化とシャットダウン
2. テキストドキュメント同期
3. 診断機能
4. 補完機能
5. その他の言語機能

### Q: Rustのコードレビューで注意すべき点は？
A: 以下を確認：
- `unsafe`の使用は最小限か
- `unwrap()`の代わりに適切なエラーハンドリング
- 所有権とライフタイムが適切か
- `clippy`の警告がないか

### Q: パフォーマンステストの記録は？
A: 以下を記載：
- ベンチマークコード（`criterion`使用）
- 測定結果（レスポンスタイム、メモリ使用量）
- 最適化前後の比較

---

このガイドラインに従うことで、Rust LSPサーバー開発の進行状況が透明化され、品質の高い実装が実現できます。
```

